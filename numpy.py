# -*- coding: utf-8 -*-
"""numpy.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1DFKFWggXRc3u0GkmvMy0ssb7fTtxATi2
"""

import numpy as np

"""1. Creating Arrays"""

# Creating NumPy arrays
arr = np.array([1, 2, 3, 4, 5])
zeros = np.zeros((3, 3))  # Creating an array filled with zeros
ones = np.ones((2, 4))  # Creating an array filled with ones

# Printing the arrays
print("Array 'arr':", arr)
print("Array 'zeros':\n", zeros)
print("Array 'ones':\n", ones)

"""2. Array Indexing and Slicing"""

# Array Indexing and Slicing
print(arr[0])  # Accessing elements
print(arr[1:4])  # Slicing elements

"""3. Array Reshaping"""

# Array Reshaping
reshaped = arr.reshape(5, 1)  # Reshaping arrays
print(reshaped)

"""4. Mathematical Operations"""

arr = np.array([1, 2, 3, 4, 5])
arr2 = np.array([6, 7, 8, 9, 10])

add = arr + arr2  # Element-wise addition
sub = arr - arr2  # Element-wise subtraction
mul = arr * arr2  # Element-wise multiplication
div = arr / arr2  # Element-wise division
mod = arr % arr2  # Element-wise modulo

# Printing the results
print("Addition:", add)
print("Subtraction:", sub)
print("Multiplication:", mul)
print("Division:", div)
print("Modulo:", mod)

"""5. Universal Functions (ufunc)"""

arr = np.array([1, 2, 3, 4, 5])

# Square root of each element
sqrt_arr = np.sqrt(arr)

# Exponential function (e^x) for each element
exp_arr = np.exp(arr)

# Sine of each element
sin_arr = np.sin(arr)

# Logarithm (base 10) for each element
log_arr = np.log10(arr)

# Printing the results
print("Square root:", sqrt_arr)
print("Exponential function:", exp_arr)
print("Sine:", sin_arr)
print("Logarithm (base 10):", log_arr)

"""6. Statistical Operations"""

arr = np.array([3, 5, 1, 7, 9, 2, 6, 8, 4, 10])

# Calculate mean
mean = np.mean(arr)

# Calculate median
median = np.median(arr)

# Calculate standard deviation
std_dev = np.std(arr)

# Calculate variance
variance = np.var(arr)

# Calculate minimum and maximum values
min_val = np.min(arr)
max_val = np.max(arr)

# Printing the statistical results
print("Mean:", mean)
print("Median:", median)
print("Standard Deviation:", std_dev)
print("Variance:", variance)
print("Minimum value:", min_val)
print("Maximum value:", max_val)

"""7. Array Concatenation and Splitting"""

arr1 = np.array([[1, 2, 3], [4, 5, 6]])
arr2 = np.array([[7, 8, 9], [10, 11, 12]])

# Concatenating arrays vertically
concatenated_vertical = np.vstack((arr1, arr2))

# Concatenating arrays horizontally
concatenated_horizontal = np.hstack((arr1, arr2))

# Printing the concatenated arrays
print("Concatenated Vertically:")
print(concatenated_vertical)
print("\nConcatenated Horizontally:")
print(concatenated_horizontal)

# Splitting arrays vertically
split_vertical = np.vsplit(concatenated_vertical, 2)

# Splitting arrays horizontally
split_horizontal = np.hsplit(concatenated_horizontal, 2)

# Printing the split arrays
print("\nSplit Vertically:")
print(split_vertical)
print("\nSplit Horizontally:")
print(split_horizontal)

"""8. Array Stacking"""

# Create sample arrays
arr1 = np.array([1, 2, 3])
arr2 = np.array([4, 5, 6])

# Horizontal stacking
horizontal_stack = np.hstack((arr1, arr2))

# Vertical stacking
vertical_stack = np.vstack((arr1, arr2))

# Depth-wise stacking
depth_stack = np.dstack((arr1, arr2))

# Print the stacked arrays
print("Horizontal Stack:")
print(horizontal_stack)

print("\nVertical Stack:")
print(vertical_stack)

print("\nDepth-wise Stack:")
print(depth_stack)

"""9. Broadcasting"""

# Create a sample array
arr = np.array([[1, 2, 3], [4, 5, 6]])

# Add a scalar to the array using broadcasting
result = arr + 10

# Print the result
print("Array after adding 10:\n", result)

"""11. Random Number Generation"""

# Generating random integers
random_integers = np.random.randint(1, 100, size=(3, 3))  # Generates a 3x3 array of random integers from 1 to 100
print("Random Integers:\n", random_integers)

# Generating random floating-point numbers from a uniform distribution
random_floats = np.random.rand(2, 4)  # Generates a 2x4 array of random floats in the half-open interval [0.0, 1.0)
print("Random Floats:\n", random_floats)

# Generating random numbers from a standard normal distribution (mean 0, variance 1)
random_normal = np.random.randn(2, 3)  # Generates a 2x3 array from the standard normal distribution
print("Random Normal Distribution:\n", random_normal)

"""12. Array Manipulation"""

arr = np.arange(6)  # Create an array from 0 to 5
reshaped_arr = arr.reshape(2, 3)  # Reshape to a 2x3 array
print(reshaped_arr)

flattened_arr = reshaped_arr.flatten()
print(flattened_arr)

transposed_arr = reshaped_arr.T  # Transpose the 2x3 array
print(transposed_arr)

arr1 = np.array([[1, 2], [3, 4]])
arr2 = np.array([[5, 6], [7, 8]])

concatenated_axis0 = np.concatenate((arr1, arr2), axis=0)  # Concatenate along axis 0
concatenated_axis1 = np.concatenate((arr1, arr2), axis=1)  # Concatenate along axis 1

print("Concatenated along axis 0:\n", concatenated_axis0)
print("Concatenated along axis 1:\n", concatenated_axis1)

arr_to_split = np.arange(9)  # Create an array from 0 to 8
split_arr = np.split(arr_to_split, 3)  # Split the array into 3 equal parts
print(split_arr)

"""13. Finding Unique Values"""

arr = np.array([1, 2, 3, 2, 4, 1, 5])

# Using np.unique to find the unique values
unique_values = np.unique(arr)
print(unique_values)

unique, counts = np.unique(arr, return_counts=True)
unique_with_counts = np.asarray((unique, counts)).T
print(unique_with_counts)

arr_2d = np.array([[1, 2], [3, 2], [4, 3], [1, 2]])

# Checking for unique rows
unique_rows = np.unique(arr_2d, axis=0)
print(unique_rows)

"""14. Linear Algebra Operations"""

matrix_a = np.array([[1, 2], [3, 4]])
matrix_b = np.array([[2, 0], [1, 2]])
# Matrix multiplication using np.dot
result = np.dot(matrix_a, matrix_b)
print(result)

matrix = np.array([[1, 2], [3, 4]])

# Transposing a matrix
transposed_matrix = matrix.T
print(transposed_matrix)

matrix = np.array([[1, 2], [3, 4]])

# Calculating determinant
det = np.linalg.det(matrix)
print(det)

matrix = np.array([[1, 2], [3, 4]])

# Finding the inverse of a matrix
inverse_matrix = np.linalg.inv(matrix)
print(inverse_matrix)

matrix = np.array([[1, 2], [3, 4]])

# Singular Value Decomposition
u, s, vh = np.linalg.svd(matrix)
print("U:", u)
print("S:", s)
print("VH:", vh)

"""15. Save and Load NumPy Arrays"""

arr = np.array([[1, 2, 3], [4, 5, 6]])

# Save the array to a file
np.save('my_array.npy', arr)

# Load the array from the saved file
loaded_array = np.load('my_array.npy')
print(loaded_array)